const {isEmpty} = require('ramda')

const getFilter = (filter = {}) => {
    if (isEmpty(filter)) return '1 = 1'
    const ands = filter.AND;
    const ors = filter.OR;
    if (!ands && !ors) {
        return resolveOneFilter(filter)
    } else if (ands) {
        return '(' + ands.map(and => getFilter(and)).join(' AND ') + ' )';
    } else {
        return '(' + ors.map(or => getFilter(or)).join(' OR ') + ' )';
    }
}

const resovleOrderBy = (orderBy) => {
    let order = orderBy ? ` ORDER BY   ` : '';
    (orderBy || []).map(({field, direction}, index) => {
        order += `${field}  ${direction} ${index == orderBy.length - 1 ? '' : ', '}`;
    })
    return order
}


const resolveOneFilter = (filter = {}) => {
    if (isEmpty(filter) || filter == null) return '1 = 1'
    if (filter.AND || filter.OR) return resovleFilter(filter);
    let conditions = [];
    for (let name in filter) {
        let value = filter[name];
        if (value === undefined) value = '';
        if (value === null) {
            name = name.split('_')
            if (name[1]) {
                conditions.push(` ${name[0]} IS  NOT  NULL`)
            } else {
                conditions.push(` ${name[0]} IS  NULL`)
            }
        } else {
            value = value === true ? '1' : value === false ? '0' : value;
            conditions.push(`${resolveFilterCondition(name, value)} ${name.endsWith('_between') ? '' : `'${value}'`}`);
        }
    }
    return conditions.join(' AND ')
}


const resolveFilterCondition = (name, value) => {

    let type = name.split('_');
    name = type[0];
    type = type.length > 1 ? type[1] : 'e';

    const FilterCondition = {
        e: ' = ',
        ne: ' != ',
        like: ' LIKE ',
        notLike: ' NOT LIKE ',
        gt: ' > ',
        gte: ' >= ',
        lt: ' < ',
        lte: ' <= ',
        in: ' IN ',
        notIn: ' NOT IN ',
        between: ' BETWEEN '
    }

    return `  ${name} ${type == 'between' ? `BETWEEN ${value[0]} AND ${value[1]}` : FilterCondition[type]} `;
}

module.exports = {
    resolveOneFilter,
    resovleOrderBy,
    getFilter
}