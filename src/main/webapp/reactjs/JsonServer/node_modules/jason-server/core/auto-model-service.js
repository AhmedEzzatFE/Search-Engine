const fs = require('fs')
const {merge, isEmpty, omit} = require('ramda')
const {getTableName, getPaths, doModelFunc, getFieldsInfo} = require("./util")
const uuid = require('node-uuid')
const {createSql, updateSql, selectSql, deleteSql, countSql} = require('./model-action')
const {getConfig} = require('./config')

let services = {};

const paths = getPaths(getConfig('model_dir'), '.type.sql');

for (const path of paths || []) {
    const content = fs.readFileSync(path, 'utf-8');
    const table = getTableName(content);
    const fieldInfo = getFieldsInfo(content).map(x => x.field);

    services['create' + table] = {
        apiFun: async ({conn}, input) => {
            const id = uuid.v4();
            let result = await  doModelFunc(conn, createSql(table, input, fieldInfo, id));
            result = JSON.stringify(result);
            result = JSON.parse(result)
            if (result.affectedRows > 0) {
                return {...input, id}
            }
        }
    }

    services['update' + table] = {
        apiFun: async ({conn}, input = {}) => {
            let result = await  doModelFunc(conn, updateSql(table, input));
            result = JSON.stringify(result)
            JSON.parse(result)
            if (result.affectedRows > 0) {
                return true
            }
        }
    }

    services['upsert' + table] = {
        apiFun: async ({conn}, input) => {
            if (input.id) {
                let result = await  doModelFunc(conn, updateSql(table, {
                    [table.toLowerCase()]: omit(['id'], input),
                    filter: {id: input.id}
                }));
                result = JSON.stringify(result)
                return JSON.parse(result)
            } else {
                const id = uuid.v4();
                let result = await  doModelFunc(conn, createSql(table, input, fieldInfo, id));
                result = JSON.stringify(result);
                result = JSON.parse(result)
                if (result.affectedRows > 0) {
                    return {...input, id}
                }
            }
        }
    }

    services['delete' + table] = {
        apiFun: async ({conn}, input = {}) => {
            let result = await  doModelFunc(conn, deleteSql(table, input));
            result = JSON.stringify(result);
            result = JSON.parse(result)
            return {deletedNum: result.affectedRows}
        }
    }

    services['findOne' + table] = {
        ignoreCheckToken: true,
        apiFun: async ({conn}, input) => {
            let result = await  doModelFunc(conn, selectSql(table, {filter: input}, fieldInfo).replace('5000', '1'));
            result = JSON.stringify(result);
            result = JSON.parse(result)
            return result.length > 0 ? result[0] : null;
        }
    }

    services['findAll' + table] = {
        ignoreCheckToken: true,
        apiFun: async ({conn}, input = {}) => {
            let result = await  doModelFunc(conn, selectSql(table, input, fieldInfo));
            result = JSON.stringify(result)
            return JSON.parse(result)
        }
    }

    services['count' + table] = {
        ignoreCheckToken: true,
        apiFun: async ({conn}, input) => {
            let result = await  doModelFunc(conn, countSql(table, {filter: input}));
            result = JSON.stringify(result);
            result = JSON.parse(result)
            return result[0]['COUNT(*)'];
        }
    }
}

module.exports = {services}
